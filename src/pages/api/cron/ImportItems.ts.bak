import type { NextApiRequest, NextApiResponse } from "next";
import { env } from "~/env.mjs";
import { db } from "~/server/db";
import { Prisma } from '@prisma/client'

export interface AppDetailsPriceOverview {
  err: string;
  res: Item[];
}

export interface Item {
  name:     string;
  rarity:   Rarity;
  subtype:  string;
  comment:  string;
  enUiType: string;
  ruUiType: string;
  chUiType: string;
  enName:   string;
  ruName:   string;
  chName:   string;
}

export enum Rarity {
  Base = "BASE",
  Common = "COMMON",
  Epic = "EPIC",
  Exotic = "EXOTIC",
  Legendary = "LEGENDARY",
  Rare = "RARE",
  VeryRare = "VERY_RARE",
}

export default async function ImportItems(
  request: NextApiRequest,
  response: NextApiResponse,
): Promise<void> {
  const authHeader = request.headers.authorization;
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      console.error("Failed authorization");
      return response.status(401).json({ success: false });
  }
  try {

    await db.steamAppPrice.createMany({data: batchSteamAppPrices});


    if (batchAppErrors.length === 0) {
        return response.status(200).json({ success: true, data: batchSteamAppPrices });
      } else {
        console.error("Error fetching one or more apps:", batchAppErrors);
        return response.status(200).json({ success: true, data: batchSteamAppPrices, appErrors: batchAppErrors });
      }
    } catch (error) {
    console.error("Error fetching data:", error);
    return response.status(500).json({ error: "Failed to fetch data" });
  }
}

async function fetchSteamAppPrice(countryCode: string, appIds: string, steamAppPrices: Prisma.SteamAppPriceCreateManyInput[], appErrors: AppError[]) {
  //name,price_overview,background,release_date
  const fetchUrl =
    env.STEAM_APP_DETAILS_URL +
    `?appids=${appIds}&cc=${countryCode}&filters=price_overview`;

  // console.log(`Fetching data from: ${fetchUrl}`);
  const result = await fetch(fetchUrl);
  const data = await result.text();

  if (data) {
    let reformatted = data.substring(1, data.length - 1);
    reformatted = '{"apps":[' + reformatted + "]}";
    reformatted = reformatted.replace(/"(\d+)":{/g, '{"appId":$1,');

    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const json: AppDetailsPriceOverview = JSON.parse(reformatted);

    for (const app of json.apps) {
      if (
        app.success !== undefined &&
        app.success &&
        app.data.price_overview !== undefined
      ) {
        let steamAppPrice = steamAppPrices.find((p) => p.steamAppId === app.appId);
        if (typeof steamAppPrice === "undefined") {
          steamAppPrice = {
            steamAppId: app.appId,
            timestamp: new Date(),
            priceUSD: 0,
            priceEUR: 0,
            priceGBP: 0,
            priceRUB: 0,
            discount: 0,
          };
          steamAppPrices.push(steamAppPrice);
        }

        switch (countryCode) {
          case "us":
            steamAppPrice.priceUSD = app.data.price_overview.final;
            steamAppPrice.discount = app.data.price_overview.discount_percent;
            break;
          case "de":
            steamAppPrice.priceEUR = app.data.price_overview.final;
            break;
          case "uk":
            steamAppPrice.priceGBP = app.data.price_overview.final;
            break;
          case "ru":
            steamAppPrice.priceRUB = app.data.price_overview.final;
            break;
        }
      } else {
        let appError = appErrors.find((e) => e.appId === app.appId);
        if (typeof appError === "undefined") {
          appError = {
            appId: app.appId,
            countryCode: [],
          };
          appErrors.push(appError);
        }
        appError.countryCode.push(countryCode);
      }
    }
  } else {
    const appError: AppError = {
      appId: 0,
      countryCode: [],
      data: data,
    };
    appError.countryCode.push(countryCode);
    appErrors.push(appError);
  }
}
